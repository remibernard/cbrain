
<%-
#
# CBRAIN Project
#
# Copyright (C) 2008-2012
# The Royal Institution for the Advancement of Learning
# McGill University
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
-%>


<%= render :partial => 'shared/active_filters', :locals => {:model => :userfile} %>


<div class="pagination">
  <%= render :partial => 'userfiles/pagination' %>
</div>

<%= index_table @userfiles, :class => "resource_list", :id => "userfiles_table" do |t| %>
  <%
    t.row_attributes do |u|
      if params[:find_file_id].to_s == u.id.to_s
        { :class => "selected_row row_highlight" }
      elsif u.available?
        { :class =>"#{cycle("list-odd", "list-even")} row_highlight" }
      else
        { :class => "row_highlight", :title => "This file is unavailable due to its provider being offline" }
      end
    end
    t.column(select_all_checkbox("userfiles_checkbox")) do |u|
      check_box_tag("file_ids[]", u.id.to_s, current_session.persistent_userfile_ids[u.id.to_s], :class  => 'userfiles_checkbox', :disabled => !u.available?)
    end
    t.describe_sort_column("Filename", 'Userfile', 'name', :class => "left shrinkable") do |col|
      col.cell(:class => "left shrinkable") do |u|
        filename_listing(u,
          :html_options => { :class => !u.available? ? 'error_link' : nil },
          :query_params => { :sort_index => @current_offset + @userfiles.index(u) }
        )
      end
    end
    t.sort_column("File Type", 'Userfile', 'type', :filters => basic_filters_for(@filtered_scope, @header_scope, Userfile, :type)) { |u| u.pretty_type }
  %>
  <% unless @filter_params["details"] == 'off' %>
    <% t.sort_column("Owner", 'User', 'login', :filters => association_filters_for(@filtered_scope, @header_scope, Userfile, :user, :name_method => "login")) { |u| link_to_user_if_accessible(u.user) } %>
    <% t.reverse_sort_column("Creation Date", 'Userfile', 'created_at') do |u| %>
     <%=  html_tool_tip(to_localtime(u.created_at,:date), :offset_x => 0, :offset_y => 20) do %>
          Created: <%= u.created_at.in_time_zone.strftime("%a %b %d, %Y at %H:%M:%S %Z") %><br/>
          Updated: <%= u.updated_at.in_time_zone.strftime("%a %b %d, %Y at %H:%M:%S %Z") %>
     <% end %>
    <% end %>
  <% end %>
  <% t.sort_column("Size", 'Userfile', 'size') do |u| %>
    <%= u.archived? ? archived_icon : "" %>
    <% if u.size.present?  %>
      <span title="<%= u.size %> bytes"><%= u.archived ? colored_pretty_size(u.size) : colored_format_size(u) %></span>
    <% else %>
      <%= html_colorize("unknown","red") %>
    <% end %>
    <% if u.archived? %>
      <% before_archiving_size      = u.meta[:before_archiving_size].presence %>
      <% before_archiving_num_files = u.meta[:before_archiving_num_files].presence %>
      <% if before_archiving_size || before_archiving_num_files %>
      (was:
        <%= colored_pretty_size(before_archiving_size) %> in
        <%= before_archiving_num_files ? view_pluralize(before_archiving_num_files, "file") + ")" : "unknown)" %>
      <% end %>
    <% end %>
  <% end %>
  <% t.column("Tags", :filters => @tag_filters) { |u| u.get_tags_for_user(current_user).collect{ |t| h(t.name) }.join("<br>").html_safe } %>
  <%
    unless current_project
       t.describe_sort_column("Project", 'Group', 'name', :filters => association_filters_for(@filtered_scope, @header_scope, Userfile, :group)) do |col|
         col.cell(:if => Proc.new { |u| u.group } ) { |u| link_to_group_if_accessible(u.group) }
       end
     end
     t.describe_sort_column("Project Access", 'Userfile', 'group_writable') do |col|
       col.cell(:if => Proc.new { |u| u.group } ) { |u| u.group_writable ? 'Read/Write' : 'Read Only' }
     end
     unless @filter_params["details"] == 'off'
       t.sort_column("Provider", 'DataProvider', 'name', :filters => association_filters_for(@filtered_scope, @header_scope, Userfile, :data_provider)) { |u| link_to_data_provider_if_accessible(u.data_provider) }
     end
  %>
<% end %>

